/*auto-generated by: https://github.com/pmndrs/gltfjsx*/import React, {useRef, useState, useEffect} from 'react'import {useFrame} from 'react-three-fiber'import {useGLTF} from '@react-three/drei/useGLTF'import {GLTF} from 'three/examples/jsm/loaders/GLTFLoader'import {    AnimationAction,    AnimationMixer,    Bone, Group,    LoopOnce,    MeshStandardMaterial,    MeshToonMaterial,    SkinnedMesh} from "three";import {hexStringToCode} from "../../../utils/color";import {SkeletonUtils} from "three/examples/jsm/utils/SkeletonUtils";import {setMaterials, setShadows} from "../../../utils/models";import {Event} from "three/src/core/EventDispatcher";type GLTFResult = GLTF & {    nodes: {        Demon001: SkinnedMesh        Body: Bone        Head: Bone    }    materials: {        Texture: MeshStandardMaterial    }}type ActionName =    | 'Bite_Front'    | 'Bite_InPlace'    | 'Dance'    | 'Death'    | 'HitRecieve'    | 'Idle'    | 'Jump'    | 'No'    | 'Walk'    | 'Yes'type GLTFActions = Record<ActionName, AnimationAction>const lightOrangeIndividualMaterial = new MeshToonMaterial({    color: hexStringToCode("#630721"),    skinning: true,});lightOrangeIndividualMaterial.color.convertSRGBToLinear();export default function Demon({isDead, lastHit, lastAttacked, ...props}: JSX.IntrinsicElements['group'] & {    isDead: boolean,    lastHit: number,    lastAttacked: number,}) {    const group = useRef<Group>()    const {nodes, materials, animations, scene} = useGLTF('/Demon.glb') as GLTFResult    const [geometry]: any = useState(() => {        const clonedScene = SkeletonUtils.clone(scene)        setMaterials(clonedScene, {            Texture: lightOrangeIndividualMaterial        })        setShadows(clonedScene)        return clonedScene    })    const currentAnimationRef = useRef<{        key: string | null,        animation: any,        finished: boolean,    }>({        key: null,        animation: null,        finished: false,    })    const actions = useRef<GLTFActions>()    const [mixer] = useState(() => new AnimationMixer(nodes.Demon001))    useFrame((state, delta) => mixer.update(delta))    useEffect(() => {        actions.current = {            Bite_Front: mixer.clipAction(animations[0], group.current),            Bite_InPlace: mixer.clipAction(animations[1], group.current),            Dance: mixer.clipAction(animations[2], group.current),            Death: mixer.clipAction(animations[3], group.current),            HitRecieve: mixer.clipAction(animations[4], group.current),            Idle: mixer.clipAction(animations[5], group.current),            Jump: mixer.clipAction(animations[6], group.current),            No: mixer.clipAction(animations[7], group.current),            Walk: mixer.clipAction(animations[8], group.current),            Yes: mixer.clipAction(animations[9], group.current),        }        actions.current.Death.loop = LoopOnce        actions.current.Death.clampWhenFinished = true        actions.current.HitRecieve.loop = LoopOnce        actions.current.HitRecieve.clampWhenFinished = true        actions.current.Bite_Front.loop = LoopOnce        actions.current.Bite_Front.clampWhenFinished = true        return () => animations.forEach((clip) => mixer.uncacheClip(clip))    }, [])    useEffect(() => {        let unsubscribe = () => {}        const calculateAnimation = () => {            if (!actions.current) return            const currentAnimation = currentAnimationRef.current            const duration = 0.2            const quickDuration = 0.05            const playAnimation = (animation: any, fadeInDuration: number, fadeDuration: number, key: string | null) => {                if (currentAnimation.animation) {                    currentAnimation.animation.fadeOut(fadeDuration)                } else {                    fadeInDuration = 0                }                animation                    .reset()                    .setEffectiveWeight(1)                    .fadeIn(fadeInDuration)                    .play();                currentAnimation.animation = animation                currentAnimation.key = key                currentAnimation.finished = false            }            const isAttacking = lastAttacked > Date.now() - 100            const isHit = lastHit > Date.now() - 100            const hitKey = lastHit.toString()            const attackKey = lastAttacked.toString()            const processAnimation = (key: string, animation: any) => {                if (!actions.current) return                if (currentAnimation.animation && currentAnimation.key === key) {                } else {                    playAnimation(animation, quickDuration, quickDuration, key)                }                const onFinished = (event: Event) => {                    mixer.removeEventListener('finished', onFinished)                    if (actions.current && event.action === animation) {                        currentAnimation.finished = true                        calculateAnimation()                    }                }                mixer.addEventListener('finished', onFinished)                unsubscribe = () => {                    mixer.removeEventListener('finished', onFinished)                }            }            if (isDead) {                playAnimation(actions.current.Death, duration, duration, null)            } else if (isAttacking || (currentAnimation.key === attackKey && !currentAnimation.finished)) {                processAnimation(attackKey, actions.current.Bite_Front)            } else if (isHit || (currentAnimation.key === hitKey && !currentAnimation.finished)) {                processAnimation(hitKey, actions.current.HitRecieve)            } else {                playAnimation(actions.current.Dance, duration, duration, null)            }        }        calculateAnimation()        return () => {            unsubscribe()        }    }, [isDead, lastHit, lastAttacked])    return (        <group ref={group} {...props} dispose={null}>            <primitive object={geometry} dispose={null} />        </group>    )}useGLTF.preload('/Demon.glb')